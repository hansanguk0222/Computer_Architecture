# 명령어 파이프라이닝

CPU의 성능은 프로그램 처리 시간에 직접적인 영향을 준다. 따라서 우리는 속도를 향상시키는 방법들을 고안하였는데 그 중 가장 간단하면서 분명한 효과를 얻는 것이 명령어 파이프라이닝이다. 명령어 파이프라이닝은 하드웨어를 독립적인 여러 단계로 분리하고 동시에 서로 다른 명령어를 처리하도록 함으로 CPU의 성능을 높여주는 기술이다. 이제 명령어파이프 라이닝에 대하여 자세히 알아보자

<br>



## 2단계 명령어 파이프라인

2단계 명령어 파이프라인은 인출 단계와 실행 단계라는 두 개의 파이프 라인 단계들로 분리하여 구성하는 방법이다. 그런 다음 두 파이프 라인 단계들에 하나의 클록 신호를 동시에 인가하면 그 단계들의 동작 시간을 일치시킬 수 있다. 결과적으로 명령어를 인출하는 동시에 명령어 실행을 동시에 하게 된다. 다음에 실행될 명령어를 미리 인출하는 것을 명령어 선인출이라고 한다.

<img src="https://github.com/hansanguk0222/Computer_Architecture/blob/master/git%EC%9E%90%EB%A3%8C/CPU/2%EB%8B%A8%EA%B3%84%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8.jpg?raw=true" alt="2단계파이프라인"  />

2단계 명령어 파이프라인을 사용함으로써 얻을 수 있는 최대 속도 향상은 2배이다. 하지만 명령어 인출과 실행이 같은 길이에 시간이 소요될 때만 적용할 수 있다. 일반적인 프로그램은 실행 단계에서 실행 시간이 인출 시간에서 실행시간 보다 길다. 이러한 이유로 실제로 2배 만큼 빨라지지는 않는다.

<br>



## 4단계 명령어 파이프라인

파이프라인 단계들의 처리 시간이 동일하지 않음으로 인하여 발생하는 효율 저하를 처리 시간이 더 긴 파이프라인 단계를 여러개로 분할하는 방법으로 단계들의 처리 시간이 거의 같아지게 하는 방법이다. 즉 파이프라인의 단계의 수를 늘리면 처리 시간이 거의 같아지도록 하는 것이다. 이에 따라 속도 향상도 높아진다.

![4단계 명령어 파이프라인](https://github.com/hansanguk0222/Computer_Architecture/blob/master/git%EC%9E%90%EB%A3%8C/CPU/4%EB%8B%A8%EA%B3%84%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8.jpg?raw=true)

4단계 명령어 파이프라인을 사용함으로써 얻게 되는 최대 속도 향상은 4배이다. 하지만 4배는 기댓값으로 일반적인 상황에서는 적용되지 못한다.

<br>



파이프라인을 사용하여 N개의 명령어를 k단계의 파이프라인으로 처리할 때 거리는 시간 T는 다음과 같다.

<p align="center"><img src="https://github.com/hansanguk0222/Computer_Architecture/blob/master/git%EC%9E%90%EB%A3%8C/CPU/%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC.gif?raw=true"></p>

<br>



일반적인 방법이 아닌 파이프라인을 사용하여 명령어를 처리했을 때 얻을 수 있는 이득은 다음과 같다.

<p align="center"><img src="https://github.com/hansanguk0222/Computer_Architecture/blob/master/git%EC%9E%90%EB%A3%8C/CPU/%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8Sp.gif?raw=true"></p>

<br>



4단계  파이프라인 문제점을 들자면 다음과 같은 문제점이 존재한다.

* 4단계 명령어 파이프라인 문제점
  1. 모든 명령어들이 4개의 파이프 라인을 모두 거치지 않는다. 즉 필요없는 시간 소모 발생함
  2. 파이프라인 클록은 처리 시간이 가장 오래 걸리는 단계를 기준으로 정해야 한다. 즉 필요 없는 시간 소모가 발생함
  3. IF단계와 OF단계에서 모두 기억장치 액세스가 필요한데 하나의 기억장치 모듈을 두 단계가 동시에 엑세스 할 수 없어서 둘 중의 하나는 지연된다. 즉 필요없는 시간소모 발생
  4. 조건 분기 명령어나 인터럽트 명령어가 실행된다면 미리 인출되어 파이프라인에서 처리되고 있던 명령어들이 무효화될 수 있다는 것이다. 처리가 되지 못한 명령어들은 사이클이 통째로 날라가는데 이런 경우도 필요없는 사이클을 사용함으로써 시간소모가 발생한다는 것이다.

<br>



이러한 문제들 중에서 조건 분기나 인터럽트 명령어를 해결하기 위해서는 다음과 같은 방법이 사용된다. 

* 조건 분기나 인터럽트 명령어 문제점 해결법
  1. 분기 예측 : 분기가 일어날 것인지 예측하고 그에 따라 어느 경로의 명령어를 인출할 지 결정하는 확률적 방법으로 최근에는 분기 역사 표를 참조
  2. 분기 목적지 선인출 : 조건 분기가 인식되면, 분기 명령어의 다음 명령어뿐 아니라, 조건이 만족될 경우에 분기하게 될 목적지의 명령어도 함께 인출, 이 방법을 위하여 분기 목적지 명령어를 별도로 저장하는 기억 장소가 추가되야 한다.
  3. 루프 버퍼 : 파이프라인의 IF단계에 포함되어 있는 작은 고속 기억장치로 가장 최근에 인출된 일정 개수의 명령어들이 순서대로 저장, 분기가 발생하면 루프 버퍼를 확인해서 명령어가 존재한다면 루프 버퍼에서 명령어가 인출
  4. 지연 분기 : 분기 명령어의 재배치함으로써 파이프라인의 성능을 개선하는 방법

<br>



조건 분기 명령어에서 사용되는 조건들은 CPU 내부의 상태 레지스터에 저장된다. 각 조건의 상태를 나타내는 비트를 플래그라고 하는데 이것들을 모아놓은 공간이 상태 레지스터이다. CPU는 실행 사이클 동안에 조건 분기 명령어가 지정하는 플래그의 값을 검사하여 분기 여부를 결정한다.

* 조건 분기 플래그 종류
  1. 부호 플래그(S) : 직전에 수행된 산술 연산 결과값의 부호 비트로 세트, 0은 양수이고 1은 음수
  2. 제로 플래그(Z) : 연산 결과값이 0이면 플래그가 1로 세트
  3. 올림수 플래그(C) : 덧셈이나 뺄셈에서 carry나 borrow가 발생한 경우 발생
  4. 동등 플래그(E) : 두 수를 비교한 결과가 동일한 경우 세트
  5. 오버 플래그(V) : 산술 연산 과정에서 오버플로우가 발생하면 세트
  6. 인터럽트 플래그(I) : 인터럽트 가능 상태이면 0, 인터럽트 불가능 상태이면 1로 세트
  7. 슈퍼바이저 플래그(p) : CPU가 슈퍼바이저 모드에서 사용되면 세트

<br>



## 슈퍼스칼라

CPU의 처리 속도를 더욱 높이기 위하여 내부에 두개 혹은 그 이상의 파이프라인을 포함시키는 구조이다. 

![슈퍼 스칼라](https://github.com/hansanguk0222/Computer_Architecture/blob/master/git%EC%9E%90%EB%A3%8C/CPU/%EC%8A%88%ED%8D%BC%EC%8A%A4%EC%B9%BC%EB%9D%BC.jpg?raw=true)

슈퍼 스칼라에서 유의할 점은 동시에 처리할 명령어들이 서로 간에 영향없이 독립적으로 실행될 수 있어야 한다는 것이다. 즉 각 파이프라인에서 데이터 의존성이 존재하지 않아야 한다는 것이다. 다음과 같은 슈퍼 스칼라 파이프라인을 활용하면 최대 속도 향상은 8배이다.

<br>



슈퍼스칼라 프로세서가 N개의 명령어들을 실행하는 데 걸리는 시간은 다음과 같다. 각 영문자가 의미하는 것은 위와 동일하다.

<p align="center"><img src="https://github.com/hansanguk0222/Computer_Architecture/blob/master/git%EC%9E%90%EB%A3%8C/CPU/%EC%8A%88%ED%8D%BC%EC%8A%A4%EC%B9%BC%EB%9D%BC.gif?raw=true"></p>

<br>



일반적인 파이프라인 프로세서와 비교했을 때, 슈퍼스칼라 프로세서로 얻을 수 있는 속도 향상은 다음과 같다.

<p align="center"><img src="https://github.com/hansanguk0222/Computer_Architecture/blob/master/git%EC%9E%90%EB%A3%8C/CPU/%EC%8A%88%ED%8D%BC%EC%8A%A4%EC%B9%BC%EB%9D%BCSp.gif?raw=true"></p>

<br>



CPU가 동시에 처리할 수 있는 명령어들의 수가 늘어나게 되면 기억장치와 레지스터에 대한 충돌이 발생하지 않을 수 있도록 만드는 것이 중요하다. 즉 하드웨어를 추가해야 한다. 실제로 독립적으로 실행될 수 있는 명령어들이 파이프라인의 수만큼 존재하지 않거나, 명령어들 간에 데이터 의존성이 존재하는 상황이 발생하는데 파이프라인에서 일부 단계 상태들이 idle상태에 들어가서 속도는 이론적인 수치보다 항상 낮게 나온다.

<br>



## 듀얼 코어와 멀티코어

서버급 컴퓨터시스템에서는 프로그램 처리 속도를 높이기 위하여 한 시스템 내에 여러 개의 CPU를 탑재한다. CPU의 기술이 발전할 수록 여러개의 코어가 CPU 내부에 들어갈 수 있게 되었는데 이렇게 하나의 CPU의 여러 개의 코어를 집어 넣은 것을 멀티-코어 프로세서라고 한다. 



멀티-코어 프로세서는 슈커스칼라 구조로 구성된다. 또한 CPU 코어가  슈퍼스칼라의 명령어 파이프라인에 비하여 독립성이 높다. 각 CPU 코어는 별도의 하드웨어 모듈로 구성된 상태로 칩에 포함되고 시스템 버스 인터페이스와 내부 캐시만 공유한다. 이것은 일반적인 슈퍼스칼라와 다르게 멀티-코어 프로세서에서는 독립적인 처리가 가능한 단위로 분할된 테스크 프로그램들이 CPU 코어들에 의해 동시에 처리된다는 것이다. 이러한 기술을 멀티-태스킹이라고 한다.