# 명령어 세트

cpu를 위해 정의되어 있는 명령어들의 집합을 명령어 세트라고 한다. 명령어 세트에 대하여 자세히 알아보자

<br>



## 명령어 세트 조건

명령어 세트가 구성되기 위해서는 다음과 같은 내용이 필요하다

* 명령어 세트 기본 구성 요소
  * 연산 종류 : cpu가 수행할 연산들의 수와 종류 및 복잡도
  * 데이터 형식 : 연산이 수행될 데이터들의 형태로 데이터의 길이와 수의 표현 방식을 뜻함
  * 명령어 형식 : 명령어의 길이, 오퍼랜드 필드의 개수 길이를 지정
  * 주소지정 방식 : 오퍼랜드의 주소를 지정하는 방식

<br>



## 연산의 종류

CPU가 연산을 수행할 수 있는 연산은 컴퓨터 종류에 따라 다양하다. 그 중에서 반드시 수행하는 공통적인 연산에 대해 설명하자면 다음과 같다.

* 공통 연산의 종류
  * 데이터 전송 : 레지스터와 레지스터간, 레지스터와 기억장치 간, 기억장치와 기억장치 간에 데이터를 이동하는 동작, 기억 장치의 주소를 계산하는 경우도 존재
  * 산술 연산 : 사칙연산을 말한다. 나머지 연산도 포함하자
  * 논리 연산 : 데이터의 각 비트들 간에 AND, OR, NOT, exclusive-OR dustksdmf tngod
  * 입출력 : CPU와 외부 장치들 간의 데이터 이동을 위한 동작이 수행
  * 프로그램 제어 : 명령어 실행 순서를 변경하는 연산, 분기와 서브루틴이 존재

<br>



## 서브루틴

프로그램 제어하는 부분 중 서브루틴 부분에 대하여 조금 깊이 학습하고자 한다. 서브루틴은 현재 돌아가고 있는 프로그램 안에서 다른 프로그램이 시작되어 그 프로그램이 끝난 뒤 원래의 프로그램으로 돌아오는 현상을 이야기한다.  서브루틴을 위한 두 가지 기본적인 명령어는 다음과 같다.

* 서브루틴을 호출하는 기본적인 명령어

  * CALL : 서브루틴을 호출하는 명령어

  * RET : 서브루틴으로부터 원래 프로그램으로 복귀시키는 명령어

  * ```javascript
    //CALL X(X번지에 있는 명령어를 사용)
    //t0 : MBR <- PC
    //t1 : MAR <- SP, PC <- X
    //t2 : M[MAR] <- MBR, SP <- SP - 1
    
    //RET(원래 프로그램으로 복귀)
    //t0 : SP <- SP +1
    //t1 : MAR <- SP
    //t2 : PC <- M[MAR]
    ```

<br>



## 명령어 형식

명령어는 CPU에 의해 실행될 때 제공해야 할 모든 정보를 포함하고 있어야 하는데 그 중 기본적인 요소를 나열하면 다음과 같다.

* 명령어 형식 기본 요소
  * 연산 코드 : 수행될 연산을 지정한다
  * 오퍼랜드 : 연산을 수행하는 데 필요한 데이터 혹은 데이터의 주소를 나타낸다
    * 각 연산은 한 개 혹은 두개의 입력 오퍼랜드들과 한 개의 결과 오퍼랜드를 가진다.
  * 다음 명령어 주소 : 현재의 명령어 실행이 완료된 후에 명령어를 인출할 위치를 나타낸다. 
    * 순차적으로 다음 명령어가 실행되는 경우에는 이 부분이 필요 없다.



각 명령어는 CPU의 한 번에 처리할 수 있는 데이터의 길이의 따라 비트 수가 주어진다. 다음에 설명할 내용들은 16비트 명령어를 기준으로 설계한 것이다. 16비트 명령어 형식은 다음과 같다(다음 예는 연산코드를 4비트, 오퍼랜드를 12비트로 설정). 

| 연산코드 | 오퍼랜드 |
| :------: | :------: |
|    4     |    12    |



다음과 같은 예를 가정하면 우리는 2^4개의 연산이 가능하고 오퍼랜드로 12비트를 쓸 수 있다는 것을 알 수 있다. 또한 연산코드를 5비트로 늘린다면 2^5개의 연산이 가능하지만 오퍼랜드를 11비트만 쓸 수 있따는 사실을 알 수 있다.



오퍼랜드 필드는 오퍼랜드가 다음과 같은 세 가지 중의 어떤 것인지에 따라 필요한 비트수가 달라질 수 있어서 배정되는 비트들의 수에 따라 각각의 범위가 결정된다.

* 오퍼랜드 필드의 종류
  * 데이터 : 표현 가능한 수의 크기가 결정
  * 기억장치 주소 : CPU가 오퍼랜드 인출을 위하여 직접 주소를 지정할 수 있는 기억장치 영역의 범위가 결정
  * 레지스터 번호 : 데이터 저장에 사용될 수 있는 내부 레지스터들의 수가 결정



우리는 명령어 형식에 따라서 오퍼랜드 필드를 나눌 수 있다. 총 기준은 총 세가지이다. 참고로 연산코드는 4비트 오퍼랜드는 12비트로 가정하였다.

* 명령어 형식에 따른 오퍼랜드 필드

  * 1주소 명령어

    * 한 개의 오퍼랜드를 가지는 명령어

    * 결과 값을 항상 AC에 저장
  
    * | 연산코드 | 오퍼랜드 |
      | -------- | -------- |
      | 4        | 12       |

  * 2주소 명령어

    * 두 개의 오퍼랜드를 가지는 명령어

    * 결과 값을 항상 오퍼랜드1에 저장
  
    * 오퍼랜드가 용도에 맞게 정확히 절반은 나누어지지 않지만 편의를 위하여 절반으로 나누었다고 가정

    * | 연산코드 | 오퍼랜드1 | 오퍼랜드2 |
      | -------- | --------- | --------- |
      | 4        | 6         | 6         |

  * 3주소 명령어

    * 세 개의 오퍼랜드를 가지는 명령어
  
    * 결과 값을 항상 오퍼랜드1에 저장

    * 오퍼랜드가 용도에 맞게 정확히 같은 비트를 나누어 가지지 않지만 편의를 위하여 정확히 나누었다고 가정
    
    * | 연산코드 | 오퍼랜드1 | 오퍼랜드2 | 오퍼랜드3 |
      | -------- | --------- | --------- | --------- |
      | 4        | 4         | 4         | 4         |
    
      
