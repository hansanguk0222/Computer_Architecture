# 주소지정방식

명령어의 길이가 늘어나면 오퍼랜드 필드의 수와 각 필드의 비트수가 증가할 수 있다. 이런 경우 명령어 비트의 수는 CPU가 처리하는 word의 길이와 같도록 제한된다. 따라서 제한된 수의 명령어 비트들을 이용하여 사용자로 하여금 가능한 한 다양한 방법으로 오퍼랜드를 지정하고 더 큰 용량의 기억장치를 사용할 수 있도록 하기 위한 여러가지 주소 지정방식이 제안되었다.



주소지정방식을 위하여 여러가지 표기들을 사용하는데 그 표기들을 정리해 보았다.

* 주소지정방식 표기
  * EA : 유효주소, 즉 데이터가 저장된 기억장치의 실제 주소
  * A : 명령어 내의 주소필드 내용
  * R : 명령어 내의 레지스터 번호
  * (A) : 기억장치 A번지의 내용
  * (R) : 레지스터 R의 내용

<br>



## 주소지정방식 종류

명령어가 실행되는 과정에서 주소지정 방식에 따라 유효 주소인 EA가 결정되며, EA는 실제 데이터를 읽어오기 위한 주소로 사용한다. 주소지정 방식이 복잡해질수록 EA를 결정하는데 걸리는 시간이 더 길어진다. 이제 여러가지 주소지정방식을 알아보자



* 주소지정방식

  * 직접 주소지정 방식(EA = A)

    <img src="https://github.com/hansanguk0222/Computer_Architecture/blob/master/git%EC%9E%90%EB%A3%8C/CPU/%EC%A7%81%EC%A0%91%EC%A3%BC%EC%86%8C%EC%A7%80%EC%A0%95%EB%B0%A9%EC%8B%9D.jpg?raw=true" alt="직접주소지정방식" height="280" width="800" /> 

    * 명령어 내 오퍼랜드 필드의 내용이 데이터의 유효 주소로 사용되는 가장 간단한 방식
    * 한 번의 기억장치 액세스만 필요하여 유효 주소 결정을 위한 다른 절차나 게산이 필요 없다
    * 직접 엑세스할 수 있는 기억장치 주소 공간이 오퍼랜드 필드의 비트 수에 의해 제약

    

  * 간접 주소지정 방식(EA = (A))

    <img src="https://github.com/hansanguk0222/Computer_Architecture/blob/master/git%EC%9E%90%EB%A3%8C/CPU/%EA%B0%84%EC%A0%91%EC%A3%BC%EC%86%8C%EC%A7%80%EC%A0%95%EB%B0%A9%EC%8B%9D.jpg?raw=true" alt="간접주소지정방식" height="280" width="800" /> 
    
    * 명령어의 오퍼랜드 필드의 기억장치 주소가 가라키는 기억 장소에 실제 사용할 데이터의 유효 주소를 저장해두는 방식
    * 최대 기억장치 용량이 그 기억 장소에 저장된 전체 비트 수에 의해 결정되어 그 범위가 확장 될 수 있다.
    * I비트로 직접 주소지정인지 간접 주소지정인지 표현(1이면 간접주소 방식, 0이면 직접주소 방식
    * 실행 사이클 동안의 두 번의 기억장치 액세스가 필요하다.
    
    
    
  * 묵시적 주소지정 방식
  
    <img src="https://github.com/hansanguk0222/Computer_Architecture/blob/master/git%EC%9E%90%EB%A3%8C/CPU/%EB%AC%B5%EC%8B%9C%EC%A0%81%EC%A3%BC%EC%86%8C%EC%A7%80%EC%A0%95%EB%B0%A9%EC%8B%9D.jpg?raw=true" alt="묵시적 주소지정 방식" width="900" height="100"/> 
  
    * 명령어 실행에 필요한 데이터의 위치를 지정하지 않더라도 이미 묵시적으로 정해짐
    * SHL명령어, PUSH, POP이 해당됨
    * 오퍼랜드가 없거나 한 개뿐이기 때문에 명령어 길이가 짧다