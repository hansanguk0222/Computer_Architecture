# 주소지정방식

명령어의 길이가 늘어나면 오퍼랜드 필드의 수와 각 필드의 비트수가 증가할 수 있다. 이런 경우 명령어 비트의 수는 CPU가 처리하는 word의 길이와 같도록 제한된다. 따라서 제한된 수의 명령어 비트들을 이용하여 사용자로 하여금 가능한 한 다양한 방법으로 오퍼랜드를 지정하고 더 큰 용량으ㅢ 기억장치를 사용할 수 있도록 하기 위한 여러가지 주소 지정방식이 제안되었다.

<br>



주소지정방식을 위하여 여러가지 표기들을 사용하는데 그 표기들을 정리해 보았다.

* 주소지정방식 표기
  * EA : 유효주소, 즉 데이터가 저장된 기억장치의 실제 주소
  * A : 명령어 내의 주소필드 내용
  * R : 명령어 내의 레지스터 번호
  * (A) : 기억장치 A번지의 내용
  * (R) : 레지스터 R의 내용

<br>



## 주소지정방식 종류

명령어가 실행되는 과정에서 주소지정 방식에 따라 유효 주소인 EA가 결정되며, EA는 실제 데이터를 읽어오기 위한 주소로 사용한다. 주소지정 방식이 복잡해질수록 EA를 결정하는데 걸리는 시간이 더 길어진다. 이제 여러가지 주소지정방식을 알아보자

<br>



* 주소지정방식

  * 직접 주소지정 방식(EA = A)

    * 명령어 내 오퍼랜드 필드의 내용이 데이터의 유효 주소로 사용되는 가장 간단한 방식
    * 한 번의 기억장치 엑세스만 필요하여 유효 주소 결정을 위한 다른 절차나 게산이 필요 없다
    * 직접 엑세스할 수 있는 기억장치 주소 공간이 오퍼랜드 필드의 비트 수에 의해 제한

    <img src="https://github.com/hansanguk0222/Computer_Architecture/blob/master/git%EC%9E%90%EB%A3%8C/CPU/%EC%A7%81%EC%A0%91%EC%A3%BC%EC%86%8C%EC%A7%80%EC%A0%95%EB%B0%A9%EC%8B%9D.jpg?raw=true" alt="직접주소지정방식" style="zoom: 50%;" />

  * 간접 주소지정 방식

    * 



